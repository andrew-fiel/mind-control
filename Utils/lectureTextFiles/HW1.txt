 
 
 
CS 370: OPERATING SYSTEMS Spring 2020   Colorado State University 
 HW1: Programming Assignment   v 1.25.2020.6:00PM 
WORKING WITH MEMORY ALLOCATIONS AND DEALLOCATIONS 
 
The objective of this assignment is to write and test a program with dynamic memory allocation. 
 
Due Date: Thursday, February 6, 2020, 11:00 pm 
Extended Due Date with 20% penalty: Friday, February 7, 2019, 11:00 pm 
 
This document and the HW1_student.zip file are available at Canvas (Assignments > HW1) 
 
1.     Description of Task 
 
For this assignment you will be working with two C files: Invoker.c and the Analyze.c. It involves 
dynamically allocating and deallocating random sized arrays. You will use the Valgrind tool to 
ensure that there are no memory leaks.   
 
Invoker: It is responsible for:    
1. Setting the seed, whose value is passed as an argument, using srand(). 
2. Invoking functions in the Analyze. 
  
Analyze: It is responsible for implementing the core functionality of this assignment, that is: 
1. Dynamically allocating and de-allocating a random sized array for each iteration. 
2. Populating elements in the array with random integers. 
3. Counting the square numbers (e.g., 16) and non-square numbers (e.g., 17) in the array. 
4. Computing the ratio of squares to non-squares.  
5. Obtaining and returning the average value of the ratio of squares to non-squares for all 
iterations. 
 
All above tasks are implemented in get_running_ratio() and the Invoker should call that function 
in the Analyze file. The auxiliary methods that will be needed in the Analyze are: 
1. int get_iteration_count(int rand): This function takes in a random value generated 
by rand() and returns a value between 100(inclusive) and 500(exclusive), which should be 
used as number of iterations. 
2. int get_arr_size(int rand): This function takes in a random value generated by 
rand() and returns a value between 100(inclusive) and 800(exclusive), which should be 
used as the array size for the array in one iteration. This function should be called once for 
per iteration. 
3. int get_arr_val(int rand): This function takes in a random value generated by rand() 
and generates a value between 1 (inclusive) and 1000 (exclusive), which is then returned 
to the calling function. 
4. float get_running__ratio(): This function takes generates an array size, allocates 
memory for the array on the heap, populates the array, gets the ratio of square numbers to 
non-square numbers, and returns the average ratio among all the arrays. 
 
Hints:  
1. To generate a number between an inclusive lower bound and an exclusive upper bound using a 
random number generated by rand() you can use the following example. 
  int generator(int randvalue) { 
   return randvalue % (upper_bound - lower_bound) + lower_bound; 
  } 
All print statements must indicate the program that is responsible for generating them. To do this, 
please prefix your print statements with the program name i.e. Invoker or Analyze. The example 
section below depicts these sample outputs. 
 
1 
 
 
 
 
 
 
CS 370: OPERATING SYSTEMS Spring 2020   Colorado State University 
Using valgrind, ensure that there is no memory leak. Copy the valgrind output indicating no leaks to 
README file. Then insert a memory leak by commenting out the code responsible for deallocation while 
ensuring that the program still functions as specified and copy the valgrind output to README file. 
Modify the program again so that it does not have a memory leak before submitting it by 
commenting the memory leak and placing a comment about it stating the below commented 
code is a memory leak. 
 
2.   Task Requirements 
 
1. The Invoker accepts one command line argument. This is the seed for the random number 
generator. 
 
 “Random” number generators and seeds 
 The random number generators used in software are actually pseudorandom. The generator is 
 initialized with a “seed” value, then a mathematical formula generates a sequence of 
 pseudorandom numbers. If you re-use the same “seed”, you get that same sequence of 
 
 numbers again. 
  
  Other uses of seeding the random number generator 
 Seeding the random number generator is useful for debugging in discrete event simulations 
 particularly stochastic ones. When a beta tester observes a problem in the program, you can 
 re-create exactly the same simulation they were running. It can also be used to create a 
 repeatable “random” run for timing purposes. 
  
 
We will be using different “seeds” to verify the correctness of your implementation.  
 
  
In the Invoker file, the seed should be set for the random number generator based on the 
command line argument that is provided. The string value received from the command line 
argument should be converted to integer using atoi() before being used to set seed using 
srand(). 
 
 srand(seed); 
 
 
The Invoker program should invoke the Analyze.  
 
 float running_ratio = get_running_ratio(); 
 printf("[Invoker] Running ratio: %f\n\n", running_ratio); 
 
 
2. The Analyze uses the random number generator to compute the number of times that it must 
allocate and de-allocate arrays. The number of iterations should be between 100 (inclusive) and 
500 (exclusive, i.e. not including 500). The auxiliary method called get_iteration_count(int 
rand) is to be used to map a given random integer into the above range. To generate a random 
number, invoke rand(). Steps 3 through 6 (enumerated below) are repeated in this loop and the 
number of times the loop is executed is dependent on the number of iterations that was returned. 
 
3. The Analyze uses the random number generator to compute the size of the array that must be 
allocated. The array size should be between 100 (inclusive) and 800 (exclusive). Again, auxiliary 
method called get_arr_size(int rand) is used to map a random number to this range. The 
Analyze must allocate the memory on the heap; failure to do so will result in a 75-point 
deduction. 
 
 Allocating on the heap versus the stack 
 An array is created in the heap by explicitly allocating memory using malloc or similar 
functions. On the other hand, allocating an array in the stack can be done as follows: int 
arr[num_of_elem];. Allocating on the stack can also be done using the alloca function. This 
function is, however, machine and compiler dependent. 
2 
If memory is allocated on the heap, it should be released explicitly (e.g. using 'free') where as 
 
memory is automatically released for stack allocations when they go out of scope – hence the 
 penalty. 
 
 
 
 
CS 370: OPERATING SYSTEMS Spring 2020   Colorado State University 
 
 
 
 
 
 
 
4. After the Analyze has allocated the array, it uses the random number generator to populate 
each element of the array. The auxiliary method called get_arr_val(int rand) is used to 
map the random number to the range 1 (inclusive) and 1000 (exclusive). This auxiliary method 
is called once for each element. 
 
5. The Analyze  then calls return_ratio(int *arr, int size), by passing it the array and 
its size . In this auxiliary function the number of square and non-square numbers in the array is 
found, and so is the ratio of squares to non-squares.  
 
6. Control returns from return_ratio(int *arr, int size) to get_running_ratio(). 
 
7. Once loop variable initialized in Step 2 has reached its limit, you exit from the loop and obtain 
the average value of the ratio. 
 
8. Control then returns to the Invoker. In Invoker print the average ratio. Check your values using 
provided sample output. 
 
 Testing for randomness  
 There exist a number of rigorous tests for randomness for sequences generated by 
 pseudorandom generators.  The test here is a rather simple one. 
  
 
3.   Files Provided 
 
Files provided for this assignment include the description file (this file), a README file. This can be 
downloaded as a package from the course web site. 
 
Please refer to the README.txt file inside the package on how to compile and run the program. You 
are needed to answer the questions in the README file. 
 
 
  
4.    Example Outputs: 
1. <system_name>:<folder_path> $  ./HW1 3 
[Invoker] With seed: 3 
[Analyze] Number of Iterations: 446 
[Invoker] Running ratio: 0.032039 
 
 
2. <system_name>:<folder_path> $ ./HW1 64 
[Invoker] With seed: 64 
[Analyze] Number of Iterations: 396 
[Invoker] Running ratio: 0.032327  
  
3 
 
 
 
 
 
 
CS 370: OPERATING SYSTEMS Spring 2020   Colorado State University 
Sample valgrind output: 
 
1. No leaks 
 
==2101== HEAP SUMMARY: 
==2101==     in use at exit: 0 bytes in 0 blocks 
==2101==   total heap usage: 447 allocs, 447 frees, 809,828 bytes 
allocated 
==2101==  
==2101== All heap blocks were freed -- no leaks are possible 
==2101==  
==2101== For counts of detected and suppressed errors, rerun with: -v 
==2101== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0) 
 
2. With Leaks 
 
==9016== HEAP SUMMARY: 
==9016==     in use at exit: 808,804 bytes in 446 blocks 
==9016==   total heap usage: 447 allocs, 1 frees, 809,828 bytes allocated 
==9016==  
==9016== LEAK SUMMARY: 
==9016==    definitely lost: 808,804 bytes in 446 blocks 
==9016==    indirectly lost: 0 bytes in 0 blocks 
==9016==      possibly lost: 0 bytes in 0 blocks 
==9016==    still reachable: 0 bytes in 0 blocks 
==9016==         suppressed: 0 bytes in 0 blocks 
==9016== Rerun with --leak-check=full to see details of leaked memory 
==9016==  
==9016== For counts of detected and suppressed errors, rerun with: -v 
==9016== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)  
 
 5.    What to Submit 
Use the CS370 Canvas to submit a single .zip or .tar file that contains: 
 
 All .c and .h files listed below and descriptive comments within, 
o Invoker.c 
o Analyze.c 
o Analyze.h – This header files declares the methods exposed from Analyze.c, so that 
they can be invoked from the Invoker program 
 a Makefile, 
 a README.txt file containing a description of each file and any information you feel the grader 
needs to grade your program, and 
o Valgrind outputs showing both no memory leaks and a memory leak 
o Answers for the 5 questions 
 
For this and all other assignments, ensure that you have submitted a valid .zip/.tar file. After submitting 
your file, you can download it and examine to make sure it is indeed a valid zip/tar file, by trying to 
extract it. 
 
Filename Convention: The archive file must be named as: <FirstName>-<LastName>-
HW1.<tar/zip>. E.g. if you are John Doe and submitting for assignment 1, then the tar file should be 
named John-Doe-HW1.tar  
 
 
4 
 
 
 
 
 
 
CS 370: OPERATING SYSTEMS Spring 2020   Colorado State University 
 6.    Grading 
The assignments must compile without warnings and function correctly on machines in the CSB-120 
Lab. Assignments that work on your laptop on your particular flavor of Linux/Mac OS X, but not on the 
Lab machines are considered unacceptable. 
The grading will also be done on a 100 point scale. The points are broken up as follows: 
 
Objective Points 
Correctly performing Tasks 1-8 (10 points each) 80 points 
Descriptive comments 5 points 
Correctly injecting and then fixing the memory leak, and providing copies of valgrind 5 points 
outputs showing both no memory leaks and a memory leak was detected 
Questions in the README file 5 points 
Providing a working Makefile 5 points 
 
Questions: (To be answered in README file. Each question worth 1 point) 
1. Malloc allocates memory dynamically on heap? – True/False 
2. When dynamically allocating an integer array, malloc takes the number of elements as the 
input? – True/False 
3. free() is defined inside which header file? 
4. How many executable(s) are required to be generated by the Makefile for this assignment? 
5. What command is used to call the default target in Makefile? 
 
Deductions: 
 There is a 75-point deduction (i.e. you will have a 25 on the assignment) if you: 
 (1) Allocate the array on the stack instead of the heap. 
(2) Have memory leak or a segmentation error which cannot be plugged by commenting the 
memory leak code provided, which is identified by placing a comment just above it. 
 
You are required to work alone on this assignment. 
 
 7.    Late Policy 
Click here for the class policy on submitting late assignments. 
 
 
 
 
 
Revisions: Any revisions in the assignment will be noted below. 
 
1/25/2020: What to submit: makefile requirements deleted, since a makefile is already provided. 
 
5 
 
 
 

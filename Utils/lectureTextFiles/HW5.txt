CS 370: OPERATING SYSTEMS Spring 2020   Colorado State University 
 
HW5: Programming Assignment   v 3.27.20.9:00PM 
PRODUCER - CONSUMER PROBLEM: SYNCHRONIZATION & DEADLOCKS 
 
This assignment requires synchronization when a producer and multiple consumers access a buffer. The 
problem you will be solving is the bounded-buffer producer-consumer problem using threads in Java. 
Due Date: Thursday, April 9, 2020, 11:00PM 
Extended Due Date with 20% penalty: Friday, April 10, 2020, 11:00PM 
 
1.     Description of Task 
For this assignment we will be solving the producer-consumer problem with a bounded buffer. You are 
required to implement this assignment in Java.  
1. The Bounded Buffer (Buffer.java): This buffer can hold a fixed number of items. This buffer needs to 
be a first-in first-out (FIFO) buffer. You should implement this as a Circular Buffer that satisfies the 
FIFO. There should be exactly one instance of the buffer. The producer and the consumers must 
reference the same buffer.  
2. Producer (Producer.java): The producer is responsible for producing data items to be added to the 
buffer. If the buffer is full, the producer must wait for a consumer to consume at least one item before 
it can add a new item to the buffer. The producer is required to produce a given number of items. The 
item that the producer adds to the buffer is a random uppercase letter 'A' to 'Z', inclusive. There are an 
arbitrary number of producer threads running at any given time. 
When a producer successfully inserts an item in the buffer it should print the location of insertion and 
time when insertion occurs with nanosecond resolution, using this format (spaces matter): 
Producer   2 inserted 'S' at index   0 at 023187855ns  
 
A checksum (really, just a sum) is used to keep the sum of all the values inserted by the producer. For 
example, if three elements 'P', 'D', and 'Q' are inserted by the producer, then the checksum will be the 
sum of their ASCII values 80, 68, and 81, namely, 229. When a producer successfully inserts an item 
in the buffer, only then it should also add it to the checksum. It should have a function called 
getCheckSum() which returns the checksum to the calling function.  The time is simply the number of 
nanoseconds since the start of the program execution, always displayed with nine digits. 
To avoid having each Producer producing the same “random” letters, each Producer must seed the 
random number generator with the given seed plus its ID number.  That is, if the given seed is 5678, 
the third producer must seed the random number generator with 5681. 
3. Consumers (Consumer.java): The consumers are responsible for consuming elements, generated by 
the producer, from the buffer. If the buffer is empty, the consumers must wait for the producer to add 
an item to the buffer. There may be one or more consumer threads running at the same time. 
When a consumer successfully removes an item from the buffer it should print the location of removal 
and time when removal occurs with nanosecond resolution, using this format: 
Consumer   2 consumed 'I' at index   7 at 024491579ns  
 
When a consumer successfully consumes an item from the buffer it should also add it to the checksum. 
It should have a function called getCheckSum() which returns the checksum to the calling function. 
You will use synchronized key word along with wait() and notify()/notifyAll() as the primitives to 
synchronize access to the buffer. 
CS 370: OPERATING SYSTEMS Spring 2020   Colorado State University 
 
 
The constructor of the producer class should take these arguments:  
i. A reference to the buffer it will access in common with Consumers, 
ii. Number of elements that producer should generate (total number of elements divided by the 
total number of producers), 
iii. ID of this Producer (starting at 1) 
iv. The seed which is used by the random number generator to generate the random numbers to 
be inserted.  
 
The constructor of the consumer class objects should take these arguments:  
i. A reference to the buffer it will access in common with the Producer and other Consumers, 
ii. Number of elements that this thread of consumer should consume. This is the total number of 
elements to be consumed divided by the total number of consumers, 
iii. The ID which is the number of the consumer thread, i.e. if it is the first consumer thread to be 
created, 1 should be passed, 2 for second consumer thread and so on.  
4. Main / Calling program (Coordinator.java): Your main program should accept the following command 
line arguments: 
i. Number of elements in buffer/buffer size 
ii. Number of items to be produced and consumed 
iii. Number of producers 
iv. Number of consumers 
v. Seed (This will be referred to as seedProvided later on in the document) 
The producer thread terminates when the specified number of items have been produced. Main/Calling 
program should print a message like this: 
Produced 18 items with checksum 1418 
 
The consumer threads terminate when the specified number of items have been consumed. Main/Calling 
program should print a message like this: 
Consumed 18 items with checksum 1418 
 
Correctness Verification:  
The items produced should match the items consumed. 
The circular buffer should work as intended. Only one thread should be able to access the buffer at a 
time. 
An item can be consumed only after it has been produced. However, if the consumption is very quick, 
within the smallest time resolution, production/consumption may appear to happen at the same time, 
and the reports may get printed in wrong order, if the consumer printing occurs first. To avoid this use 
System.out.flush() 
2.   Task Requirements 
1. Implement the FIFO Circular Buffer and ensure that the buffer can hold the right number items 
at a time, and the access to it is synchronized. 
2. The number of items to be produced/consumed should be equally distributed among the 
producer/consumer threads. You may assume that the number of elements can be perfectly 
CS 370: OPERATING SYSTEMS Spring 2020   Colorado State University 
 
divided among the producers/consumers with no fractions involved. Also, a seed is to be passed 
to the producer. 
3. The producer should wait if the buffer is full.   
4. A consumer should wait if the buffer is empty.  
5. Make sure that the printing requirements are met.  
6. Your solution must satisfy the correctness constraint i.e. you consume each item exactly once, 
in the order that it was produced, and demonstrate this by printing out the items produced and 
consumed, along with the location and the timestamp with nanosecond resolution. The code to 
get the timestamp with nanosecond resolution is provided to you, in Coordinator.java. The 
checksum of the Producer thread should be obtained after the join of Producer object, by calling 
getCheckSum() in Producer class, and the checksum of each Consumer thread is obtained after 
each Consumer thread join, by using getCheckSum() in the Consumer class, and the sum of all 
the Consumer checksums should be equal to Producer checksum. 
7. There should be no deadlock. Your program will be executed multiple times, and it should run 
to completion every time without a deadlock.  
8. Your program should work for any combination of the number of producers, number of 
consumers, number of elements and buffer size. 
3.   Files Provided 
Files provided for this assignment include the description file (this file), a README file, Coordinator.java 
and Producer.java. This can be downloaded as a package from the course Canvas assignment page. 
Please refer to the README.txt file inside the package on how to compile and run the program. You are 
needed to answer the questions in the README file. 
4.    Example Output 
1. <system_name>:<folder_path> $ java Coordinator 3 6 2 3 970 
Producer   1 inserted 'G' at index   0 at 001548148ns 
Producer   1 inserted 'Q' at index   1 at 013432509ns 
Producer   1 inserted 'R' at index   2 at 013795299ns 
Consumer   3 consumed 'G' at index   0 at 014192104ns 
Consumer   3 consumed 'Q' at index   1 at 014709511ns 
Consumer   2 consumed 'R' at index   2 at 015096188ns 
Producer   2 inserted 'E' at index   0 at 015693379ns 
Consumer   2 consumed 'E' at index   0 at 016096841ns 
Producer   2 inserted 'W' at index   1 at 016653872ns 
Producer   2 inserted 'U' at index   2 at 017039385ns 
Consumer   1 consumed 'W' at index   1 at 017386523ns 
Consumer   1 consumed 'U' at index   2 at 018008208ns 
Produced 6 items with checksum 475 
Consumed 6 items with checksum 475 
 
 
5.    What to Submit 
Use the CS370 Canvas to submit a single .zip or .tar file that contains: 
  All .java files listed below and descriptive comments within, 
o Coordinator.java 
o Producer.java 
o Consumer.java 
o Buffer.java 
  a Makefile that performs both a make build as well as a make clean, 
  a README.txt file containing a description of each file and any information you feel the grader 
needs to grade your program, and answers for the 4 questions 
CS 370: OPERATING SYSTEMS Spring 2020   Colorado State University 
 
 
For this and all other assignments, ensure that you have submitted a valid .zip/.tar file. After submitting 
your file, you can download it and examine to make sure it is indeed a valid zip/tar file, by trying to 
extract it. 
Filename: The archive file must be named as: FirstName-LastName-HW5.<tar/zip>. E.g. if you are 
John Doe, then the tar file should be named John-Doe-HW5.tar or John-Doe-HW5.zip. 
 
6.    Grading 
 
The assignments must compile and function correctly on machines in the CSB-120 Lab. Assignments 
that work on your laptop on your particular flavor of Linux/Mac OS X, but not on the Lab machines are 
considered unacceptable. 
The grading will also be done on a 100 point scale. The points are broken up as follows: 
Objective Points 
Correctly performing Tasks 1-8 (10 points each) 80 points 
Providing a working Makefile.  10 points 
Questions in the README file 5 points 
Descriptive comments  5 points 
 
Questions: (To be answered in README file. Each question worth 1 point) 
1. The problem of producer consumer is solved using __________. 1 point  
a. Mutex Locks b. Semaphores 
 
2. What two functions defined in Java are used for synchronization between producer and consumers 
in your program? __________ and __________ 2 points 
 
3. In which function do you override the body to define the new body of a thread in java? __________ 
1 point 
 
4. Which function is used to wait for a thread to finish and come back to calling program i.e. for a 
thread to die? __________ 1 point 
 
Restriction and Deductions: 
 
[R1]. There is a 100-point deduction if you use an unbounded buffer for this assignment, or a buffer 
larger than the size specified in the command line.  
[R2]. There is a 100-point deduction if you use Thread.sleep() to synchronize access to the buffer. You 
can only use wait() and notify() as the primitives to synchronize access to the buffer. Thread.sleep() 
may be used for inserting random delays. 
[R3]. Java has advanced classes for synchronization. These cannot be used for this assignment. Hence, 
there is a 100-point deduction for using any classes other than the following: 
1. java.util.Random    2. java.lang.Exception 
3. java.time.Instant    4. java.time.Clock 
5. java.time.Duration   6. java.util.Formatter 
There is a 100-point deduction for using any external library.  
CS 370: OPERATING SYSTEMS Spring 2020   Colorado State University 
 
[R4]. There is an 80-point deduction for using a Boolean flag or any variable that toggles in values so 
that your producer and consumer take turns adding to or consuming from the buffer. The solution must 
be based entirely on the use of wait() and notify()/notifyAll( ). 
 
You are required to work alone on this assignment. 
 
Notes: 
1. Use format %3d to display the Producer/Consumer ID number, and to display the index. 
2. You may assume that the number of elements to be consumed will always be a multiple of the 
number of consumers and of the number of producers. 
3. Do not define a package inside of your programs which includes all your programs, as this will raise 
an issue when the programs are run on terminals. 
 
 
7.    Late Policy 
 
Click here for the class policy on submitting late assignments. 
Revisions: Any revisions in the assignment will be noted below. 
3/30/2020: Added: You will use synchronized key word along with wait() and notify()/notifyAll() 
as the primitives to synchronize access to the buffer. 
 
 
